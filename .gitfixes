client.py:1:-#!/usr/bin/python3
client.py:1:-from tcpcom import TCPClient
client.py:1:+#!/usr/bin/python2
client.py:2:+from tcpcom2 import TCPClient
client.py:3: from socket import *
client.py:4: import time
client.py:5: 
client.py:6: print(gethostname())
client.py:7:-IP_ADDRESS = "192.168.0.17"
client.py:7:+IP_ADDRESS = "192.168.1.206"
client.py:8: IP_PORT = 22000
client.py:9: 
client.py:10: def onStateChanged(state, msg):
client.py:29:         time.sleep(2)
client.py:30:     print("Done")    
client.py:31: else:
client.py:32:-    print("Client:-- Connection failed") 
client.py:32: No newline at end of file
client.py:33:+    print("Client:-- Connection failed") 
server.py:1:-#!/usr/bin/python3
server.py:1:-from tcpcom import TCPServer
server.py:1:+#!/usr/bin/python2
server.py:2:+from tcpcom2 import TCPServer
server.py:3: from socket import *
server.py:4: 
server.py:5: import time
/dev/null:0:-# tcpcom.py
/dev/null:0:-# AP
/dev/null:0:-
/dev/null:0:-'''
/dev/null:0:- This software is part of the TCPCom library.
/dev/null:0:- It is Open Source Free Software, so you may
/dev/null:0:- - run the code for any purpose
/dev/null:0:- - study how the code works and adapt it to your needs
/dev/null:0:- - integrate all or parts of the code in your own programs
/dev/null:0:- - redistribute copies of the code
/dev/null:0:- - improve the code and release your improvements to the public
/dev/null:0:- However the use of the code is entirely your responsibility.
/dev/null:0:- '''
/dev/null:0:-
/dev/null:0:-from threading import Thread
/dev/null:0:-import thread
/dev/null:0:-import socket
/dev/null:0:-import time
/dev/null:0:-import sys
/dev/null:0:-
/dev/null:0:-TCPCOM_VERSION = "1.26 - Jan. 17, 2018"
/dev/null:0:-
/dev/null:0:-# ================================== Server ================================
/dev/null:0:-class TimeoutThread(Thread):
/dev/null:0:-    def __init__(self, server, timeout):
/dev/null:0:-        Thread.__init__(self)
/dev/null:0:-        self.server = server
/dev/null:0:-        self.timeout = timeout
/dev/null:0:-        self.count = 0
/dev/null:0:-        
/dev/null:0:-    def run(self):
/dev/null:0:-        TCPServer.debug("TimeoutThread starting")
/dev/null:0:-        self.isRunning = True
/dev/null:0:-        isTimeout = False
/dev/null:0:-        while self.isRunning:
/dev/null:0:-            time.sleep(0.01)
/dev/null:0:-            self.count += 1
/dev/null:0:-            if self.count == 100 * self.timeout:
/dev/null:0:-                self.isRunning = False
/dev/null:0:-                isTimeout = True
/dev/null:0:-        if isTimeout:        
/dev/null:0:-            TCPServer.debug("TimeoutThread terminated with timeout")
/dev/null:0:-            self.server.disconnect()
/dev/null:0:-        else:         
/dev/null:0:-            TCPServer.debug("TimeoutThread terminated without timeout")
/dev/null:0:-                
/dev/null:0:-    def reset(self):
/dev/null:0:-        self.count = 0
/dev/null:0:-
/dev/null:0:-    def stop(self):
/dev/null:0:-        self.isRunning = False
/dev/null:0:-
/dev/null:0:-class TCPServer(Thread):
/dev/null:0:-    '''
/dev/null:0:-    Class that represents a TCP socket based server.
/dev/null:0:-    '''
/dev/null:0:-    isVerbose = False
/dev/null:0:-    PORT_IN_USE = "PORT_IN_USE"
/dev/null:0:-    CONNECTED = "CONNECTED"
/dev/null:0:-    LISTENING = "LISTENING"
/dev/null:0:-    TERMINATED = "TERMINATED"
/dev/null:0:-    MESSAGE = "MESSAGE"
/dev/null:0:-
/dev/null:0:-    def __init__(self, port, stateChanged, endOfBlock = '0', isVerbose = False):
/dev/null:0:-        '''
/dev/null:0:-        Creates a TCP socket server that listens on TCP port
/dev/null:0:-        for a connecting client. The server runs in its own thread, so the
/dev/null:0:-        constructor returns immediately. State changes invoke the callback
/dev/null:0:-        onStateChanged().
/dev/null:0:-        @param port: the IP port where to listen (0..65535)
/dev/null:0:-        @param stateChange: the callback function to register
/dev/null:0:-        @param endOfBlock: character indicating end of a data block (default: '0')
/dev/null:0:-        @param isVerbose: if true, debug messages are written to System.out, default: False
/dev/null:0:-        '''
/dev/null:0:-        Thread.__init__(self)
/dev/null:0:-        self.port = port
/dev/null:0:-        self.endOfBlock = endOfBlock
/dev/null:0:-        self.timeout = 0
/dev/null:0:-        self.stateChanged = stateChanged
/dev/null:0:-        TCPServer.isVerbose = isVerbose
/dev/null:0:-        self.isClientConnected = False
/dev/null:0:-        self.terminateServer = False
/dev/null:0:-        self.isServerRunning = False
/dev/null:0:-        self.start()
/dev/null:0:-
/dev/null:0:-    def setTimeout(self, timeout):
/dev/null:0:-        '''
/dev/null:0:-        Sets the maximum time (in seconds) to wait in blocking recv() for an incoming message. If the timeout is exceeded, the link to the client is disconnected.
/dev/null:0:-        (timeout <= 0: no timeout).
/dev/null:0:-        '''
/dev/null:0:-        if timeout <= 0:
/dev/null:0:-            self.timeout = 0
/dev/null:0:-        else:
/dev/null:0:-            self.timeout = timeout
/dev/null:0:-
/dev/null:0:-    def run(self):
/dev/null:0:-        TCPServer.debug("TCPServer thread started")
/dev/null:0:-        HOSTNAME = "" # Symbolic name meaning all available interfaces
/dev/null:0:-        self.conn = None
/dev/null:0:-        self.serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
/dev/null:0:-        self.serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  # close port when process exits
/dev/null:0:-        TCPServer.debug("Socket created")
/dev/null:0:-        try:
/dev/null:0:-            self.serverSocket.bind((HOSTNAME, self.port))
/dev/null:0:-        except socket.error as msg:
/dev/null:0:-            print "Fatal error while creating TCPServer: Bind failed.", msg[0], msg[1]
/dev/null:0:-            sys.exit()
/dev/null:0:-        try:    
/dev/null:0:-            self.serverSocket.listen(10)
/dev/null:0:-        except:
/dev/null:0:-            print "Fatal error while creating TCPServer: Port", self.port, "already in use"
/dev/null:0:-            try:
/dev/null:0:-                self.stateChanged(TCPServer.PORT_IN_USE, str(self.port))
/dev/null:0:-            except Exception, e:
/dev/null:0:-               print "Caught exception in TCPServer.PORT_IN_USE:", e
/dev/null:0:-            sys.exit()
/dev/null:0:-
/dev/null:0:-        try:
/dev/null:0:-            self.stateChanged(TCPServer.LISTENING, str(self.port))
/dev/null:0:-        except Exception, e:
/dev/null:0:-            print "Caught exception in TCPServer.LISTENING:", e
/dev/null:0:-
/dev/null:0:-        self.isServerRunning = True
/dev/null:0:-                
/dev/null:0:-        while True:
/dev/null:0:-            TCPServer.debug("Calling blocking accept()...")
/dev/null:0:-            conn, self.addr = self.serverSocket.accept()
/dev/null:0:-            if self.terminateServer:
/dev/null:0:-                self.conn = conn
/dev/null:0:-                break
/dev/null:0:-            if self.isClientConnected:
/dev/null:0:-                TCPServer.debug("Returning form blocking accept(). Client refused")
/dev/null:0:-                try:
/dev/null:0:-                    conn.shutdown(socket.SHUT_RDWR)
/dev/null:0:-                except:
/dev/null:0:-                    pass
/dev/null:0:-                conn.close()
/dev/null:0:-                continue
/dev/null:0:-            self.conn = conn
/dev/null:0:-            self.isClientConnected = True
/dev/null:0:-            self.socketHandler = ServerHandler(self, self.endOfBlock)
/dev/null:0:-            self.socketHandler.setDaemon(True)  # necessary to terminate thread at program termination
/dev/null:0:-            self.socketHandler.start()
/dev/null:0:-            try: 
/dev/null:0:-                self.stateChanged(TCPServer.CONNECTED, self.addr[0])
/dev/null:0:-            except Exception, e:
/dev/null:0:-                print "Caught exception in TCPServer.CONNECTED:", e
/dev/null:0:-        self.conn.close()
/dev/null:0:-        self.serverSocket.close()
/dev/null:0:-        self.isClientConnected = False
/dev/null:0:-        try:
/dev/null:0:-            self.stateChanged(TCPServer.TERMINATED, "")
/dev/null:0:-        except Exception, e:
/dev/null:0:-            print "Caught exception in TCPServer.TERMINATED:", e
/dev/null:0:-        self.isServerRunning = False
/dev/null:0:-        TCPServer.debug("TCPServer thread terminated")
/dev/null:0:-        
/dev/null:0:-    def terminate(self):
/dev/null:0:-        '''
/dev/null:0:-        Closes the connection and terminates the server thread.
/dev/null:0:-        Releases the IP port.
/dev/null:0:-        '''
/dev/null:0:-        TCPServer.debug("Calling terminate()")
/dev/null:0:-        if not self.isServerRunning:
/dev/null:0:-            TCPServer.debug("Server not running")
/dev/null:0:-            return
/dev/null:0:-        self.terminateServer = True
/dev/null:0:-        TCPServer.debug("Disconnect by a dummy connection...")
/dev/null:0:-        if self.conn != None:
/dev/null:0:-            self.conn.close()
/dev/null:0:-            self.isClientConnected = False
/dev/null:0:-        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
/dev/null:0:-        client_socket.connect(('localhost', self.port))  # dummy connection to get out of accept()
/dev/null:0:-        
/dev/null:0:-    def disconnect(self):
/dev/null:0:-        '''
/dev/null:0:-        Closes the connection with the client and enters
/dev/null:0:-        the LISTENING state
/dev/null:0:-        '''
/dev/null:0:-        TCPServer.debug("Calling Server.disconnect()")
/dev/null:0:-        if self.isClientConnected:
/dev/null:0:-            self.isClientConnected = False
/dev/null:0:-            try:
/dev/null:0:-                self.stateChanged(TCPServer.LISTENING, str(self.port))
/dev/null:0:-            except Exception, e:
/dev/null:0:-                print "Caught exception in TCPServer.LISTENING:", e
/dev/null:0:-            TCPServer.debug("Shutdown socket now")
/dev/null:0:-            try:
/dev/null:0:-                self.conn.shutdown(socket.SHUT_RDWR)
/dev/null:0:-            except:
/dev/null:0:-                pass
/dev/null:0:-            self.conn.close()
/dev/null:0:-
/dev/null:0:-    def sendMessage(self, msg):
/dev/null:0:-        '''
/dev/null:0:-        Sends the information msg to the client (as String, the character endOfBlock (defaut: ASCII 0) serves as end of
/dev/null:0:-        string indicator, it is transparently added and removed)
/dev/null:0:-        @param msg: the message to send
/dev/null:0:-        '''
/dev/null:0:-        TCPServer.debug("sendMessage() with msg: " + msg)
/dev/null:0:-        if not self.isClientConnected:
/dev/null:0:-            TCPServer.debug("Not connected")
/dev/null:0:-            return
/dev/null:0:-        try:
/dev/null:0:-            self.conn.sendall(msg + self.endOfBlock)    
/dev/null:0:-        except:
/dev/null:0:-            TCPClient.debug("Exception in sendMessage()")
/dev/null:0:-
/dev/null:0:-    def isConnected(self):
/dev/null:0:-        '''
/dev/null:0:-        Returns True, if a client is connected to the server.
/dev/null:0:-        @return: True, if the communication link is established
/dev/null:0:-        '''
/dev/null:0:-        return self.isClientConnected
/dev/null:0:-    
/dev/null:0:-    def loopForever(self):
/dev/null:0:-        '''
/dev/null:0:-        Blocks forever with little processor consumption until a keyboard interrupt is detected.
/dev/null:0:-        '''
/dev/null:0:-        try:
/dev/null:0:-            while True:
/dev/null:0:-                time.sleep(1)
/dev/null:0:-        except KeyboardInterrupt:
/dev/null:0:-            pass
/dev/null:0:-        self.terminate()
/dev/null:0:-
/dev/null:0:-    def isTerminated(self):
/dev/null:0:-        '''
/dev/null:0:-        Returns True, if the server is in TERMINATED state.
/dev/null:0:-        @return: True, if the server thread is terminated
/dev/null:0:-        '''
/dev/null:0:-        return self.terminateServer
/dev/null:0:-
/dev/null:0:-    @staticmethod
/dev/null:0:-    def debug(msg):
/dev/null:0:-        if TCPServer.isVerbose:
/dev/null:0:-            print "   TCPServer-> " + msg
/dev/null:0:- 
/dev/null:0:-    @staticmethod
/dev/null:0:-    def getVersion():
/dev/null:0:-        '''
/dev/null:0:-        Returns the library version.
/dev/null:0:-        @return: the current version of the library
/dev/null:0:-        '''
/dev/null:0:-        return TCPCOM_VERSION
/dev/null:0:-
/dev/null:0:-    @staticmethod
/dev/null:0:-    # Hack should work on all platforms
/dev/null:0:-    def getIPAddress():
/dev/null:0:-        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
/dev/null:0:-        try:
/dev/null:0:-            # doesn't even have to be reachable
/dev/null:0:-            s.connect(('10.255.255.255', 1))
/dev/null:0:-            IP = s.getsockname()[0]
/dev/null:0:-        except:
/dev/null:0:-            IP = '127.0.0.1'
/dev/null:0:-        finally:
/dev/null:0:-            s.close()
/dev/null:0:-        return IP
/dev/null:0:-   
/dev/null:0:-class ServerHandler(Thread):
/dev/null:0:-    def __init__(self, server, endOfBlock):
/dev/null:0:-        Thread.__init__(self)
/dev/null:0:-        self.server = server
/dev/null:0:-        self.endOfBlock = endOfBlock
/dev/null:0:-
/dev/null:0:-    def run(self):
/dev/null:0:-        TCPServer.debug("ServerHandler started")
/dev/null:0:-        timeoutThread = None
/dev/null:0:-        if self.server.timeout > 0:
/dev/null:0:-            timeoutThread = TimeoutThread(self.server, self.server.timeout)
/dev/null:0:-            timeoutThread.start()
/dev/null:0:-        bufSize = 4096
/dev/null:0:-        try:
/dev/null:0:-            while True:
/dev/null:0:-                data = ""
/dev/null:0:-                reply = ""
/dev/null:0:-                isRunning = True
/dev/null:0:-                while not reply[-1:] == self.endOfBlock:
/dev/null:0:-                    TCPServer.debug("Calling blocking conn.recv()")
/dev/null:0:-                    reply = self.server.conn.recv(bufSize)
/dev/null:0:-                    TCPServer.debug("Returned from conn.recv() with " + str(reply))
/dev/null:0:-                    if reply == None or len(reply) == 0: # Client disconnected
/dev/null:0:-                        TCPServer.debug("conn.recv() returned None")
/dev/null:0:-                        isRunning = False
/dev/null:0:-                        break
/dev/null:0:-                    data += reply
/dev/null:0:-                if not isRunning:
/dev/null:0:-                    break
/dev/null:0:-                TCPServer.debug("Received msg: " + data + "; len: " + str(len(data)))
/dev/null:0:-                junk = data.split(self.endOfBlock)  # more than 1 message may be received if
/dev/null:0:-                                         # transfer is fast. data: xxxx<eob>yyyyy<eol>zzz<eob>
/dev/null:0:-                for i in range(len(junk) - 1):
/dev/null:0:-                    try:
/dev/null:0:-                        self.server.stateChanged(TCPServer.MESSAGE, junk[i]) # eol is not included
/dev/null:0:-                    except Exception, e:
/dev/null:0:-                        print "Caught exception in TCPServer.MESSAGE:", e
/dev/null:0:-                if not self.server.isClientConnected: # Callback disconnected the client
/dev/null:0:-                     if timeoutThread != None:
/dev/null:0:-                        timeoutThread.stop()
/dev/null:0:-                     TCPServer.debug("Callback disconnected client. ServerHandler terminated")
/dev/null:0:-                     return
/dev/null:0:-                if timeoutThread != None:
/dev/null:0:-                    timeoutThread.reset() 
/dev/null:0:-        except:  # May happen if client peer is resetted
/dev/null:0:-            TCPServer.debug("Exception from blocking conn.recv(), Msg: " + str(sys.exc_info()[0]) + -              " at line # " +  str(sys.exc_info()[-1].tb_lineno))
/dev/null:0:-        self.server.disconnect()
/dev/null:0:-        if timeoutThread != None:
/dev/null:0:-            timeoutThread.stop()
/dev/null:0:-        TCPServer.debug("ServerHandler terminated")
/dev/null:0:-
/dev/null:0:-
/dev/null:0:-# ================================== Client ================================
/dev/null:0:-class TCPClient():
/dev/null:0:-    '''
/dev/null:0:-    Class that represents a TCP socket based client.
/dev/null:0:-    '''
/dev/null:0:-    isVerbose = False
/dev/null:0:-    CONNECTING = "CONNECTING"
/dev/null:0:-    SERVER_OCCUPIED = "SERVER_OCCUPIED"
/dev/null:0:-    CONNECTION_FAILED = "CONNECTION_FAILED"
/dev/null:0:-    CONNECTED = "CONNECTED"
/dev/null:0:-    DISCONNECTED = "DISCONNECTED"
/dev/null:0:-    MESSAGE = "MESSAGE"
/dev/null:0:-
/dev/null:0:-    def __init__(self, ipAddress, port, stateChanged, isVerbose = False):
/dev/null:0:-        '''
/dev/null:0:-        Creates a TCP socket client prepared for a connection with a
/dev/null:0:-        TCPServer at given address and port.
/dev/null:0:-        @param host: the IP address of the host
/dev/null:0:-        @param port: the IP port where to listen (0..65535)
/dev/null:0:-        @param stateChanged: the callback function to register
/dev/null:0:-        @param isVerbose: if true, debug messages are written to System.out
/dev/null:0:-        '''
/dev/null:0:-        self.isClientConnected = False
/dev/null:0:-        self.isClientConnecting = False
/dev/null:0:-        self.ipAddress = ipAddress
/dev/null:0:-        self.port = port
/dev/null:0:-        self.stateChanged = stateChanged
/dev/null:0:-        self.checkRefused = False
/dev/null:0:-        self.isRefused = False
/dev/null:0:-
/dev/null:0:-        TCPClient.isVerbose = isVerbose
/dev/null:0:-                  
/dev/null:0:-    def sendMessage(self, msg, responseTime = 0):
/dev/null:0:-        '''
/dev/null:0:-        Sends the information msg to the server (as String, the character 0
/dev/null:0:-        (ASCII 0) serves as end of string indicator, it is transparently added
/dev/null:0:-        and removed).  For responseTime > 0 the method blocks and waits
/dev/null:0:-        for maximum responseTime seconds for a server reply.
/dev/null:0:-        @param msg: the message to send
/dev/null:0:-        @param responseTime: the maximum time to wait for a server reply (in s)
/dev/null:0:-        @return: the message or null, if a timeout occured
/dev/null:0:-        '''
/dev/null:0:-        TCPClient.debug("sendMessage() with msg = " + msg)
/dev/null:0:-        if not self.isClientConnected:
/dev/null:0:-            TCPClient.debug("sendMessage(): Connection closed.")
/dev/null:0:-            return None
/dev/null:0:-        reply = None
/dev/null:0:-        try:
/dev/null:0:-            msg += "0";  # Append 0
/dev/null:0:-            rc = self.sock.sendall(msg)
/dev/null:0:-            if responseTime > 0:
/dev/null:0:-                reply = self._waitForReply(responseTime)  # Blocking
/dev/null:0:-        except:
/dev/null:0:-            TCPClient.debug("Exception in sendMessage()")
/dev/null:0:-            self.disconnect()
/dev/null:0:-    
/dev/null:0:-        return reply
/dev/null:0:-    
/dev/null:0:-    def _waitForReply(self, responseTime):
/dev/null:0:-        TCPClient.debug("Calling _waitForReply()")
/dev/null:0:-        self.receiverResponse = None
/dev/null:0:-        startTime = time.time()
/dev/null:0:-        while self.isClientConnected and self.receiverResponse == None and time.time() - startTime < responseTime:
/dev/null:0:-            time.sleep(0.01)
/dev/null:0:-        if self.receiverResponse == None:
/dev/null:0:-            TCPClient.debug("Timeout while waiting for reply")
/dev/null:0:-        else:    
/dev/null:0:-            TCPClient.debug("Response = " + self.receiverResponse + " time elapsed: " + str(int(1000 * (time.time() - startTime))) + " ms")
/dev/null:0:-        return self.receiverResponse
/dev/null:0:-
/dev/null:0:-    def connect(self, timeout = 0):
/dev/null:0:-        '''
/dev/null:0:-        Creates a connection to the server (blocking until timeout).
/dev/null:0:-        @param timeout: the maximum time (in s) for the connection trial  (0: for default timeout)
/dev/null:0:-        @return: True, if the connection is established; False, if the server
/dev/null:0:-        is not available or occupied
/dev/null:0:-        '''
/dev/null:0:-        if timeout == 0:
/dev/null:0:-            timeout = None
/dev/null:0:-        try:
/dev/null:0:-            self.stateChanged(TCPClient.CONNECTING, self.ipAddress + ":" + str(self.port))
/dev/null:0:-        except Exception, e:
/dev/null:0:-            print "Caught exception in TCPClient.CONNECTING:", e
/dev/null:0:-        try:
/dev/null:0:-            self.isClientConnecting = True
/dev/null:0:-            host = (self.ipAddress, self.port)
/dev/null:0:-            if self.ipAddress == "localhost" or self.ipAddress == "127.0.0.1":
/dev/null:0:-                timeout = None  # do not use timeout for local host, to avoid error message "java.net..."
/dev/null:0:-            self.sock = socket.create_connection(host, timeout)
/dev/null:0:-            self.sock.settimeout(None)
/dev/null:0:-            self.isClientConnecting = False
/dev/null:0:-            self.isClientConnected = True
/dev/null:0:-        except:
/dev/null:0:-            self.isClientConnecting = False
/dev/null:0:-            try:
/dev/null:0:-                self.stateChanged(TCPClient.CONNECTION_FAILED, self.ipAddress + ":" + str(self.port))
/dev/null:0:-            except Exception, e:
/dev/null:0:-                print "Caught exception in TCPClient.CONNECTION_FAILED:", e
/dev/null:0:-            TCPClient.debug("Connection failed.")
/dev/null:0:-            return False
/dev/null:0:-        ClientHandler(self)
/dev/null:0:-
/dev/null:0:-        # Check if connection is refused
/dev/null:0:-        self.checkRefused = True
/dev/null:0:-        self.isRefused = False
/dev/null:0:-        startTime = time.time()
/dev/null:0:-        while time.time() - startTime < 2 and not self.isRefused:
/dev/null:0:-            time.sleep(0.001)
/dev/null:0:-        if self.isRefused:
/dev/null:0:-            TCPClient.debug("Connection refused")
/dev/null:0:-            try:
/dev/null:0:-                self.stateChanged(TCPClient.SERVER_OCCUPIED, self.ipAddress + ":" + str(self.port))
/dev/null:0:-            except Exception, e:
/dev/null:0:-                print "Caught exception in TCPClient.SERVER_OCCUPIED:", e
/dev/null:0:-            return False
/dev/null:0:-
/dev/null:0:-        try:
/dev/null:0:-            self.stateChanged(TCPClient.CONNECTED, self.ipAddress + ":" + str(self.port))
/dev/null:0:-        except Exception, e:
/dev/null:0:-            print "Caught exception in TCPClient.CONNECTED:", e
/dev/null:0:-        TCPClient.debug("Successfully connected")
/dev/null:0:-        return True
/dev/null:0:-
/dev/null:0:-    def disconnect(self):
/dev/null:0:-        '''
/dev/null:0:-        Closes the connection with the server.
/dev/null:0:-        '''
/dev/null:0:-        TCPClient.debug("Client.disconnect()")
/dev/null:0:-        if not self.isClientConnected:
/dev/null:0:-            TCPClient.debug("Connection already closed")
/dev/null:0:-            return
/dev/null:0:-        self.isClientConnected = False
/dev/null:0:-        TCPClient.debug("Closing socket")
/dev/null:0:-        try: # catch Exception "transport endpoint is not connected"
/dev/null:0:-            self.sock.shutdown(socket.SHUT_RDWR)
/dev/null:0:-        except:
/dev/null:0:-            pass
/dev/null:0:-        self.sock.close()
/dev/null:0:-
/dev/null:0:-    def isConnecting(self):
/dev/null:0:-        '''
/dev/null:0:-        Returns True during a connection trial.
/dev/null:0:-        @return: True, while the client tries to connect
/dev/null:0:-        '''
/dev/null:0:-        return self.isClientConnecting
/dev/null:0:-
/dev/null:0:-    def isConnected(self):
/dev/null:0:-        '''
/dev/null:0:-        Returns True of client is connnected to the server.
/dev/null:0:-        @return: True, if the connection is established
/dev/null:0:-        '''
/dev/null:0:-        return self.isClientConnected
/dev/null:0:-    
/dev/null:0:-    @staticmethod
/dev/null:0:-    def debug(msg):
/dev/null:0:-        if TCPClient.isVerbose:
/dev/null:0:-            print "   TCPClient-> " + msg
/dev/null:0:-
/dev/null:0:-    @staticmethod
/dev/null:0:-    def getVersion():
/dev/null:0:-        '''
/dev/null:0:-        Returns the library version.
/dev/null:0:-        @return: the current version of the library
/dev/null:0:-        '''
/dev/null:0:-        return TCPCOM_VERSION
/dev/null:0:-
/dev/null:0:-class ClientHandler(Thread):
/dev/null:0:-    def __init__(self, client):
/dev/null:0:-        Thread.__init__(self)
/dev/null:0:-        self.client = client
/dev/null:0:-        self.start()
/dev/null:0:-                
/dev/null:0:-    def run(self):
/dev/null:0:-        TCPClient.debug("ClientHandler thread started")
/dev/null:0:-        while True:
/dev/null:0:-            try:
/dev/null:0:-                junk = self.readResponse().split("0")
/dev/null:0:-                # more than 1 message may be received 
/dev/null:0:-                # if transfer is fast. data: xxxx0yyyyy0zzz0
/dev/null:0:-                for i in range(len(junk) - 1):
/dev/null:0:-                    try:
/dev/null:0:-                        self.client.stateChanged(TCPClient.MESSAGE, junk[i])
/dev/null:0:-                    except Exception, e:
/dev/null:0:-                        print "Caught exception in TCPClient.MESSAGE:", e
/dev/null:0:-            except:    
/dev/null:0:-                TCPClient.debug("Exception in readResponse() Msg: " + str(sys.exc_info()[0]) + -                  " at line # " +  str(sys.exc_info()[-1].tb_lineno))
/dev/null:0:-                if self.client.checkRefused:
/dev/null:0:-                    self.client.isRefused = True
/dev/null:0:-                break
/dev/null:0:-        try:
/dev/null:0:-            self.client.stateChanged(TCPClient.DISCONNECTED, "")
/dev/null:0:-        except Exception, e:
/dev/null:0:-            print "Caught exception in TCPClient.DISCONNECTED:", e
/dev/null:0:-        TCPClient.debug("ClientHandler thread terminated")
/dev/null:0:-
/dev/null:0:-    def readResponse(self):
/dev/null:0:-        TCPClient.debug("Calling readResponse")
/dev/null:0:-        bufSize = 4096
/dev/null:0:-        data = ""
/dev/null:0:-        while not data[-1:]  ==  "0":
/dev/null:0:-            try:
/dev/null:0:-                reply = self.client.sock.recv(bufSize)  # blocking
/dev/null:0:-                if len(reply) == 0:
/dev/null:0:-                    TCPClient.debug("recv returns null length")
/dev/null:0:-                    raise Exception("recv returns null length")
/dev/null:0:-            except:
/dev/null:0:-                TCPClient.debug("Exception from blocking conn.recv(), Msg: " + str(sys.exc_info()[0]) + -                  " at line # " +  str(sys.exc_info()[-1].tb_lineno))
/dev/null:0:-                raise Exception("Exception from blocking sock.recv()")
/dev/null:0:-            data += reply
/dev/null:0:-            self.receiverResponse = data[:-1]
/dev/null:0:-        return data
/dev/null:0:-
/dev/null:0:-
/dev/null:0:-class HTTPServer(TCPServer):
/dev/null:0:-    
/dev/null:0:-    def getHeader1(self):
/dev/null:0:-       return "HTTP/1.1 501 OKrnServer: " + self.serverName + "rnConnection: Closedrn"
/dev/null:0:-   
/dev/null:0:-    def getHeader2(self):
/dev/null:0:-        return "HTTP/1.1 200 OKrnServer: " + self.serverName + "rnContent-Length: %drnContent-Type: text/htmlrnConnection: Closedrnrn"
/dev/null:0:-
/dev/null:0:-    def onStop(self):
/dev/null:0:-        self.terminate()
/dev/null:0:-    
/dev/null:0:-    def __init__(self, requestHandler, serverName = "PYSERVER", port = 80, isVerbose = False):
/dev/null:0:-        '''
/dev/null:0:-
/dev/null:0:-        Creates a HTTP server (inherited from TCPServer) that listens for a connecting client on given port (default = 80). 
/dev/null:0:-        Starts a thread that handles and returns HTTP GET requests. The HTTP respoonse header reports the given server name 
/dev/null:0:-        (default: "PYSERVER")
/dev/null:0:-        
/dev/null:0:-        requestHandler() is a callback function called when a GET request is received.
/dev/null:0:-        Signature:  msg, stateHandler = requestHandler(clientIP, filename, params)
/dev/null:0:-        
/dev/null:0:-        Parameters:                
/dev/null:0:-            clientIP: the client's IP address in dotted format
/dev/null:0:-            filename: the requested filename with preceeding '/'
/dev/null:0:-            params: a tuple with format: ((param_key1, param_value1), (param_key2, param_value2), ...)  (all items are strings)
/dev/null:0:-        
/dev/null:0:-        Return values:
/dev/null:0:-            msg: the HTTP text response (the header is automatically created) 
/dev/null:0:-            stateHandler: a callback function that is invoked immediately after the reponse is sent.
/dev/null:0:-              If stateHandler = None, nothing is done. The function may include longer lasting server 
/dev/null:0:-              actions or a wait time, if sensors are not immediately ready for a new measurement.
/dev/null:0:-            
/dev/null:0:-        Call terminate() to stop the server. The connection is closed by the server at the end of each response. If the client connects,
/dev/null:0:-        but does not send a request within 5 seconds, the connection is closed by the server.
/dev/null:0:-        '''
/dev/null:0:-        try:
/dev/null:0:-            registerStopFunction(self.onStop)
/dev/null:0:-        except:
/dev/null:0:-            pass # registerStopFunction not defined (e.g. on Raspberry Pi)
/dev/null:0:-    
/dev/null:0:-        TCPServer.__init__(self, port, stateChanged = self.onStateChanged, endOfBlock = 'n', isVerbose = isVerbose)
/dev/null:0:-        self.serverName = serverName
/dev/null:0:-        self.requestHandler = requestHandler
/dev/null:0:-        self.port = port
/dev/null:0:-        self.verbose = isVerbose
/dev/null:0:-        self.timeout = 5
/dev/null:0:-        self.clientIP = ""
/dev/null:0:-    
/dev/null:0:-    def getClientIP(self):
/dev/null:0:-        '''
/dev/null:0:-        Returns the dotted IP of a connected client. If no client is connected, returns empty string.
/dev/null:0:-        '''
/dev/null:0:-        return self.clientIP                
/dev/null:0:-
/dev/null:0:-    def onStateChanged(self, state, msg):
/dev/null:0:-        if state == "CONNECTED":
/dev/null:0:-            self.clientIP = msg
/dev/null:0:-            self.debug("Client " + msg + " connected.")
/dev/null:0:-        elif state == "DISCONNECTED":
/dev/null:0:-            self.clientIP = ""
/dev/null:0:-            self.debug("Client disconnected.")
/dev/null:0:-        elif state == "LISTENING":
/dev/null:0:-            self.clientIP = ""
/dev/null:0:-            self.debug("LISTENING")
/dev/null:0:-        elif state == "MESSAGE":
/dev/null:0:-            self.debug("request: " + msg)
/dev/null:0:-            if len(msg) != 0:
/dev/null:0:-                filename, params = self._parseURL(msg)
/dev/null:0:-                if filename == None:
/dev/null:0:-                    self.sendMessage(self.getHeader1())
/dev/null:0:-                else:
/dev/null:0:-                    text, stateHandler = self.requestHandler(self.clientIP, filename, params)
/dev/null:0:-                    self.sendMessage(self.getHeader2() % (len(text)))
/dev/null:0:-                    self.sendMessage(text)
/dev/null:0:-                    if stateHandler != None:
/dev/null:0:-                        try:
/dev/null:0:-                            stateHandler()
/dev/null:0:-                        except:
/dev/null:0:-                            print "Exception in stateHandler()"
/dev/null:0:-            else:
/dev/null:0:-                self.sendMessage(self.getHeader1())
/dev/null:0:-            self.disconnect()
/dev/null:0:-          
/dev/null:0:-    def _parseURL(self, request):
/dev/null:0:-        lines = request.split('n') # split lines
/dev/null:0:-        params = []
/dev/null:0:-        for line in lines:
/dev/null:0:-            if line[0:4] == 'GET ': # only GET request
/dev/null:0:-                url = line.split()[1].strip() # split at spaces and take second item
/dev/null:0:-                i = url.find('?')  # check for params
/dev/null:0:-                if i != -1: # params given
/dev/null:0:-                    filename = url[0:i].strip()  # include leading /
/dev/null:0:-                    params = []
/dev/null:0:-                    urlParam = url[i + 1:]
/dev/null:0:-                    for item in urlParam.split('&'): # split parameters
/dev/null:0:-                        i = item.find('=')
/dev/null:0:-                        key = item[0:i]
/dev/null:0:-                        value = item[i+1:]
/dev/null:0:-                        params.append((key, value))
/dev/null:0:-                    return filename, tuple(params)    
/dev/null:0:-                return url.strip(), tuple([])
/dev/null:0:-        return None, tuple([])   
/dev/null:0:-
/dev/null:0:-    def debug(self, msg):
/dev/null:0:-        if self.verbose:
/dev/null:0:-            print("   HTTPServer-> " + msg)
/dev/null:0:-
/dev/null:0:-    @staticmethod
/dev/null:0:-    def getServerIP():
/dev/null:0:-        '''
/dev/null:0:-        Returns the server's IP address (static method).
/dev/null:0:-        '''
/dev/null:0:-        return TCPServer.getIPAddress()
/dev/null:0: No newline at end of file
